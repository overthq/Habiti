/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `CartProduct` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client';
import type * as $Enums from '../enums.js';
import type * as Prisma from '../internal/prismaNamespace.js';

/**
 * Model CartProduct
 *
 */
export type CartProductModel =
	runtime.Types.Result.DefaultSelection<Prisma.$CartProductPayload>;

export type AggregateCartProduct = {
	_count: CartProductCountAggregateOutputType | null;
	_avg: CartProductAvgAggregateOutputType | null;
	_sum: CartProductSumAggregateOutputType | null;
	_min: CartProductMinAggregateOutputType | null;
	_max: CartProductMaxAggregateOutputType | null;
};

export type CartProductAvgAggregateOutputType = {
	quantity: number | null;
};

export type CartProductSumAggregateOutputType = {
	quantity: number | null;
};

export type CartProductMinAggregateOutputType = {
	cartId: string | null;
	productId: string | null;
	quantity: number | null;
};

export type CartProductMaxAggregateOutputType = {
	cartId: string | null;
	productId: string | null;
	quantity: number | null;
};

export type CartProductCountAggregateOutputType = {
	cartId: number;
	productId: number;
	quantity: number;
	_all: number;
};

export type CartProductAvgAggregateInputType = {
	quantity?: true;
};

export type CartProductSumAggregateInputType = {
	quantity?: true;
};

export type CartProductMinAggregateInputType = {
	cartId?: true;
	productId?: true;
	quantity?: true;
};

export type CartProductMaxAggregateInputType = {
	cartId?: true;
	productId?: true;
	quantity?: true;
};

export type CartProductCountAggregateInputType = {
	cartId?: true;
	productId?: true;
	quantity?: true;
	_all?: true;
};

export type CartProductAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Filter which CartProduct to aggregate.
	 */
	where?: Prisma.CartProductWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of CartProducts to fetch.
	 */
	orderBy?:
		| Prisma.CartProductOrderByWithRelationInput
		| Prisma.CartProductOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.CartProductWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` CartProducts from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` CartProducts.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned CartProducts
	 **/
	_count?: true | CartProductCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: CartProductAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: CartProductSumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: CartProductMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: CartProductMaxAggregateInputType;
};

export type GetCartProductAggregateType<T extends CartProductAggregateArgs> = {
	[P in keyof T & keyof AggregateCartProduct]: P extends '_count' | 'count'
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateCartProduct[P]>
		: Prisma.GetScalarType<T[P], AggregateCartProduct[P]>;
};

export type CartProductGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	where?: Prisma.CartProductWhereInput;
	orderBy?:
		| Prisma.CartProductOrderByWithAggregationInput
		| Prisma.CartProductOrderByWithAggregationInput[];
	by: Prisma.CartProductScalarFieldEnum[] | Prisma.CartProductScalarFieldEnum;
	having?: Prisma.CartProductScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: CartProductCountAggregateInputType | true;
	_avg?: CartProductAvgAggregateInputType;
	_sum?: CartProductSumAggregateInputType;
	_min?: CartProductMinAggregateInputType;
	_max?: CartProductMaxAggregateInputType;
};

export type CartProductGroupByOutputType = {
	cartId: string;
	productId: string;
	quantity: number;
	_count: CartProductCountAggregateOutputType | null;
	_avg: CartProductAvgAggregateOutputType | null;
	_sum: CartProductSumAggregateOutputType | null;
	_min: CartProductMinAggregateOutputType | null;
	_max: CartProductMaxAggregateOutputType | null;
};

type GetCartProductGroupByPayload<T extends CartProductGroupByArgs> =
	Prisma.PrismaPromise<
		Array<
			Prisma.PickEnumerable<CartProductGroupByOutputType, T['by']> & {
				[P in keyof T & keyof CartProductGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: Prisma.GetScalarType<T[P], CartProductGroupByOutputType[P]>
					: Prisma.GetScalarType<T[P], CartProductGroupByOutputType[P]>;
			}
		>
	>;

export type CartProductWhereInput = {
	AND?: Prisma.CartProductWhereInput | Prisma.CartProductWhereInput[];
	OR?: Prisma.CartProductWhereInput[];
	NOT?: Prisma.CartProductWhereInput | Prisma.CartProductWhereInput[];
	cartId?: Prisma.StringFilter<'CartProduct'> | string;
	productId?: Prisma.StringFilter<'CartProduct'> | string;
	quantity?: Prisma.IntFilter<'CartProduct'> | number;
	cart?: Prisma.XOR<Prisma.CartScalarRelationFilter, Prisma.CartWhereInput>;
	product?: Prisma.XOR<
		Prisma.ProductScalarRelationFilter,
		Prisma.ProductWhereInput
	>;
};

export type CartProductOrderByWithRelationInput = {
	cartId?: Prisma.SortOrder;
	productId?: Prisma.SortOrder;
	quantity?: Prisma.SortOrder;
	cart?: Prisma.CartOrderByWithRelationInput;
	product?: Prisma.ProductOrderByWithRelationInput;
	_relevance?: Prisma.CartProductOrderByRelevanceInput;
};

export type CartProductWhereUniqueInput = Prisma.AtLeast<
	{
		cartId_productId?: Prisma.CartProductCartIdProductIdCompoundUniqueInput;
		AND?: Prisma.CartProductWhereInput | Prisma.CartProductWhereInput[];
		OR?: Prisma.CartProductWhereInput[];
		NOT?: Prisma.CartProductWhereInput | Prisma.CartProductWhereInput[];
		cartId?: Prisma.StringFilter<'CartProduct'> | string;
		productId?: Prisma.StringFilter<'CartProduct'> | string;
		quantity?: Prisma.IntFilter<'CartProduct'> | number;
		cart?: Prisma.XOR<Prisma.CartScalarRelationFilter, Prisma.CartWhereInput>;
		product?: Prisma.XOR<
			Prisma.ProductScalarRelationFilter,
			Prisma.ProductWhereInput
		>;
	},
	'cartId_productId'
>;

export type CartProductOrderByWithAggregationInput = {
	cartId?: Prisma.SortOrder;
	productId?: Prisma.SortOrder;
	quantity?: Prisma.SortOrder;
	_count?: Prisma.CartProductCountOrderByAggregateInput;
	_avg?: Prisma.CartProductAvgOrderByAggregateInput;
	_max?: Prisma.CartProductMaxOrderByAggregateInput;
	_min?: Prisma.CartProductMinOrderByAggregateInput;
	_sum?: Prisma.CartProductSumOrderByAggregateInput;
};

export type CartProductScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.CartProductScalarWhereWithAggregatesInput
		| Prisma.CartProductScalarWhereWithAggregatesInput[];
	OR?: Prisma.CartProductScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.CartProductScalarWhereWithAggregatesInput
		| Prisma.CartProductScalarWhereWithAggregatesInput[];
	cartId?: Prisma.StringWithAggregatesFilter<'CartProduct'> | string;
	productId?: Prisma.StringWithAggregatesFilter<'CartProduct'> | string;
	quantity?: Prisma.IntWithAggregatesFilter<'CartProduct'> | number;
};

export type CartProductCreateInput = {
	quantity: number;
	cart: Prisma.CartCreateNestedOneWithoutProductsInput;
	product: Prisma.ProductCreateNestedOneWithoutCartsInput;
};

export type CartProductUncheckedCreateInput = {
	cartId: string;
	productId: string;
	quantity: number;
};

export type CartProductUpdateInput = {
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
	cart?: Prisma.CartUpdateOneRequiredWithoutProductsNestedInput;
	product?: Prisma.ProductUpdateOneRequiredWithoutCartsNestedInput;
};

export type CartProductUncheckedUpdateInput = {
	cartId?: Prisma.StringFieldUpdateOperationsInput | string;
	productId?: Prisma.StringFieldUpdateOperationsInput | string;
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type CartProductCreateManyInput = {
	cartId: string;
	productId: string;
	quantity: number;
};

export type CartProductUpdateManyMutationInput = {
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type CartProductUncheckedUpdateManyInput = {
	cartId?: Prisma.StringFieldUpdateOperationsInput | string;
	productId?: Prisma.StringFieldUpdateOperationsInput | string;
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type CartProductListRelationFilter = {
	every?: Prisma.CartProductWhereInput;
	some?: Prisma.CartProductWhereInput;
	none?: Prisma.CartProductWhereInput;
};

export type CartProductOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type CartProductOrderByRelevanceInput = {
	fields:
		| Prisma.CartProductOrderByRelevanceFieldEnum
		| Prisma.CartProductOrderByRelevanceFieldEnum[];
	sort: Prisma.SortOrder;
	search: string;
};

export type CartProductCartIdProductIdCompoundUniqueInput = {
	cartId: string;
	productId: string;
};

export type CartProductCountOrderByAggregateInput = {
	cartId?: Prisma.SortOrder;
	productId?: Prisma.SortOrder;
	quantity?: Prisma.SortOrder;
};

export type CartProductAvgOrderByAggregateInput = {
	quantity?: Prisma.SortOrder;
};

export type CartProductMaxOrderByAggregateInput = {
	cartId?: Prisma.SortOrder;
	productId?: Prisma.SortOrder;
	quantity?: Prisma.SortOrder;
};

export type CartProductMinOrderByAggregateInput = {
	cartId?: Prisma.SortOrder;
	productId?: Prisma.SortOrder;
	quantity?: Prisma.SortOrder;
};

export type CartProductSumOrderByAggregateInput = {
	quantity?: Prisma.SortOrder;
};

export type CartProductCreateNestedManyWithoutProductInput = {
	create?:
		| Prisma.XOR<
				Prisma.CartProductCreateWithoutProductInput,
				Prisma.CartProductUncheckedCreateWithoutProductInput
		  >
		| Prisma.CartProductCreateWithoutProductInput[]
		| Prisma.CartProductUncheckedCreateWithoutProductInput[];
	connectOrCreate?:
		| Prisma.CartProductCreateOrConnectWithoutProductInput
		| Prisma.CartProductCreateOrConnectWithoutProductInput[];
	createMany?: Prisma.CartProductCreateManyProductInputEnvelope;
	connect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
};

export type CartProductUncheckedCreateNestedManyWithoutProductInput = {
	create?:
		| Prisma.XOR<
				Prisma.CartProductCreateWithoutProductInput,
				Prisma.CartProductUncheckedCreateWithoutProductInput
		  >
		| Prisma.CartProductCreateWithoutProductInput[]
		| Prisma.CartProductUncheckedCreateWithoutProductInput[];
	connectOrCreate?:
		| Prisma.CartProductCreateOrConnectWithoutProductInput
		| Prisma.CartProductCreateOrConnectWithoutProductInput[];
	createMany?: Prisma.CartProductCreateManyProductInputEnvelope;
	connect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
};

export type CartProductUpdateManyWithoutProductNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CartProductCreateWithoutProductInput,
				Prisma.CartProductUncheckedCreateWithoutProductInput
		  >
		| Prisma.CartProductCreateWithoutProductInput[]
		| Prisma.CartProductUncheckedCreateWithoutProductInput[];
	connectOrCreate?:
		| Prisma.CartProductCreateOrConnectWithoutProductInput
		| Prisma.CartProductCreateOrConnectWithoutProductInput[];
	upsert?:
		| Prisma.CartProductUpsertWithWhereUniqueWithoutProductInput
		| Prisma.CartProductUpsertWithWhereUniqueWithoutProductInput[];
	createMany?: Prisma.CartProductCreateManyProductInputEnvelope;
	set?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	disconnect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	delete?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	connect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	update?:
		| Prisma.CartProductUpdateWithWhereUniqueWithoutProductInput
		| Prisma.CartProductUpdateWithWhereUniqueWithoutProductInput[];
	updateMany?:
		| Prisma.CartProductUpdateManyWithWhereWithoutProductInput
		| Prisma.CartProductUpdateManyWithWhereWithoutProductInput[];
	deleteMany?:
		| Prisma.CartProductScalarWhereInput
		| Prisma.CartProductScalarWhereInput[];
};

export type CartProductUncheckedUpdateManyWithoutProductNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CartProductCreateWithoutProductInput,
				Prisma.CartProductUncheckedCreateWithoutProductInput
		  >
		| Prisma.CartProductCreateWithoutProductInput[]
		| Prisma.CartProductUncheckedCreateWithoutProductInput[];
	connectOrCreate?:
		| Prisma.CartProductCreateOrConnectWithoutProductInput
		| Prisma.CartProductCreateOrConnectWithoutProductInput[];
	upsert?:
		| Prisma.CartProductUpsertWithWhereUniqueWithoutProductInput
		| Prisma.CartProductUpsertWithWhereUniqueWithoutProductInput[];
	createMany?: Prisma.CartProductCreateManyProductInputEnvelope;
	set?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	disconnect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	delete?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	connect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	update?:
		| Prisma.CartProductUpdateWithWhereUniqueWithoutProductInput
		| Prisma.CartProductUpdateWithWhereUniqueWithoutProductInput[];
	updateMany?:
		| Prisma.CartProductUpdateManyWithWhereWithoutProductInput
		| Prisma.CartProductUpdateManyWithWhereWithoutProductInput[];
	deleteMany?:
		| Prisma.CartProductScalarWhereInput
		| Prisma.CartProductScalarWhereInput[];
};

export type CartProductCreateNestedManyWithoutCartInput = {
	create?:
		| Prisma.XOR<
				Prisma.CartProductCreateWithoutCartInput,
				Prisma.CartProductUncheckedCreateWithoutCartInput
		  >
		| Prisma.CartProductCreateWithoutCartInput[]
		| Prisma.CartProductUncheckedCreateWithoutCartInput[];
	connectOrCreate?:
		| Prisma.CartProductCreateOrConnectWithoutCartInput
		| Prisma.CartProductCreateOrConnectWithoutCartInput[];
	createMany?: Prisma.CartProductCreateManyCartInputEnvelope;
	connect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
};

export type CartProductUncheckedCreateNestedManyWithoutCartInput = {
	create?:
		| Prisma.XOR<
				Prisma.CartProductCreateWithoutCartInput,
				Prisma.CartProductUncheckedCreateWithoutCartInput
		  >
		| Prisma.CartProductCreateWithoutCartInput[]
		| Prisma.CartProductUncheckedCreateWithoutCartInput[];
	connectOrCreate?:
		| Prisma.CartProductCreateOrConnectWithoutCartInput
		| Prisma.CartProductCreateOrConnectWithoutCartInput[];
	createMany?: Prisma.CartProductCreateManyCartInputEnvelope;
	connect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
};

export type CartProductUpdateManyWithoutCartNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CartProductCreateWithoutCartInput,
				Prisma.CartProductUncheckedCreateWithoutCartInput
		  >
		| Prisma.CartProductCreateWithoutCartInput[]
		| Prisma.CartProductUncheckedCreateWithoutCartInput[];
	connectOrCreate?:
		| Prisma.CartProductCreateOrConnectWithoutCartInput
		| Prisma.CartProductCreateOrConnectWithoutCartInput[];
	upsert?:
		| Prisma.CartProductUpsertWithWhereUniqueWithoutCartInput
		| Prisma.CartProductUpsertWithWhereUniqueWithoutCartInput[];
	createMany?: Prisma.CartProductCreateManyCartInputEnvelope;
	set?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	disconnect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	delete?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	connect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	update?:
		| Prisma.CartProductUpdateWithWhereUniqueWithoutCartInput
		| Prisma.CartProductUpdateWithWhereUniqueWithoutCartInput[];
	updateMany?:
		| Prisma.CartProductUpdateManyWithWhereWithoutCartInput
		| Prisma.CartProductUpdateManyWithWhereWithoutCartInput[];
	deleteMany?:
		| Prisma.CartProductScalarWhereInput
		| Prisma.CartProductScalarWhereInput[];
};

export type CartProductUncheckedUpdateManyWithoutCartNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CartProductCreateWithoutCartInput,
				Prisma.CartProductUncheckedCreateWithoutCartInput
		  >
		| Prisma.CartProductCreateWithoutCartInput[]
		| Prisma.CartProductUncheckedCreateWithoutCartInput[];
	connectOrCreate?:
		| Prisma.CartProductCreateOrConnectWithoutCartInput
		| Prisma.CartProductCreateOrConnectWithoutCartInput[];
	upsert?:
		| Prisma.CartProductUpsertWithWhereUniqueWithoutCartInput
		| Prisma.CartProductUpsertWithWhereUniqueWithoutCartInput[];
	createMany?: Prisma.CartProductCreateManyCartInputEnvelope;
	set?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	disconnect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	delete?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	connect?:
		| Prisma.CartProductWhereUniqueInput
		| Prisma.CartProductWhereUniqueInput[];
	update?:
		| Prisma.CartProductUpdateWithWhereUniqueWithoutCartInput
		| Prisma.CartProductUpdateWithWhereUniqueWithoutCartInput[];
	updateMany?:
		| Prisma.CartProductUpdateManyWithWhereWithoutCartInput
		| Prisma.CartProductUpdateManyWithWhereWithoutCartInput[];
	deleteMany?:
		| Prisma.CartProductScalarWhereInput
		| Prisma.CartProductScalarWhereInput[];
};

export type CartProductCreateWithoutProductInput = {
	quantity: number;
	cart: Prisma.CartCreateNestedOneWithoutProductsInput;
};

export type CartProductUncheckedCreateWithoutProductInput = {
	cartId: string;
	quantity: number;
};

export type CartProductCreateOrConnectWithoutProductInput = {
	where: Prisma.CartProductWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CartProductCreateWithoutProductInput,
		Prisma.CartProductUncheckedCreateWithoutProductInput
	>;
};

export type CartProductCreateManyProductInputEnvelope = {
	data:
		| Prisma.CartProductCreateManyProductInput
		| Prisma.CartProductCreateManyProductInput[];
	skipDuplicates?: boolean;
};

export type CartProductUpsertWithWhereUniqueWithoutProductInput = {
	where: Prisma.CartProductWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.CartProductUpdateWithoutProductInput,
		Prisma.CartProductUncheckedUpdateWithoutProductInput
	>;
	create: Prisma.XOR<
		Prisma.CartProductCreateWithoutProductInput,
		Prisma.CartProductUncheckedCreateWithoutProductInput
	>;
};

export type CartProductUpdateWithWhereUniqueWithoutProductInput = {
	where: Prisma.CartProductWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.CartProductUpdateWithoutProductInput,
		Prisma.CartProductUncheckedUpdateWithoutProductInput
	>;
};

export type CartProductUpdateManyWithWhereWithoutProductInput = {
	where: Prisma.CartProductScalarWhereInput;
	data: Prisma.XOR<
		Prisma.CartProductUpdateManyMutationInput,
		Prisma.CartProductUncheckedUpdateManyWithoutProductInput
	>;
};

export type CartProductScalarWhereInput = {
	AND?:
		| Prisma.CartProductScalarWhereInput
		| Prisma.CartProductScalarWhereInput[];
	OR?: Prisma.CartProductScalarWhereInput[];
	NOT?:
		| Prisma.CartProductScalarWhereInput
		| Prisma.CartProductScalarWhereInput[];
	cartId?: Prisma.StringFilter<'CartProduct'> | string;
	productId?: Prisma.StringFilter<'CartProduct'> | string;
	quantity?: Prisma.IntFilter<'CartProduct'> | number;
};

export type CartProductCreateWithoutCartInput = {
	quantity: number;
	product: Prisma.ProductCreateNestedOneWithoutCartsInput;
};

export type CartProductUncheckedCreateWithoutCartInput = {
	productId: string;
	quantity: number;
};

export type CartProductCreateOrConnectWithoutCartInput = {
	where: Prisma.CartProductWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CartProductCreateWithoutCartInput,
		Prisma.CartProductUncheckedCreateWithoutCartInput
	>;
};

export type CartProductCreateManyCartInputEnvelope = {
	data:
		| Prisma.CartProductCreateManyCartInput
		| Prisma.CartProductCreateManyCartInput[];
	skipDuplicates?: boolean;
};

export type CartProductUpsertWithWhereUniqueWithoutCartInput = {
	where: Prisma.CartProductWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.CartProductUpdateWithoutCartInput,
		Prisma.CartProductUncheckedUpdateWithoutCartInput
	>;
	create: Prisma.XOR<
		Prisma.CartProductCreateWithoutCartInput,
		Prisma.CartProductUncheckedCreateWithoutCartInput
	>;
};

export type CartProductUpdateWithWhereUniqueWithoutCartInput = {
	where: Prisma.CartProductWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.CartProductUpdateWithoutCartInput,
		Prisma.CartProductUncheckedUpdateWithoutCartInput
	>;
};

export type CartProductUpdateManyWithWhereWithoutCartInput = {
	where: Prisma.CartProductScalarWhereInput;
	data: Prisma.XOR<
		Prisma.CartProductUpdateManyMutationInput,
		Prisma.CartProductUncheckedUpdateManyWithoutCartInput
	>;
};

export type CartProductCreateManyProductInput = {
	cartId: string;
	quantity: number;
};

export type CartProductUpdateWithoutProductInput = {
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
	cart?: Prisma.CartUpdateOneRequiredWithoutProductsNestedInput;
};

export type CartProductUncheckedUpdateWithoutProductInput = {
	cartId?: Prisma.StringFieldUpdateOperationsInput | string;
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type CartProductUncheckedUpdateManyWithoutProductInput = {
	cartId?: Prisma.StringFieldUpdateOperationsInput | string;
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type CartProductCreateManyCartInput = {
	productId: string;
	quantity: number;
};

export type CartProductUpdateWithoutCartInput = {
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
	product?: Prisma.ProductUpdateOneRequiredWithoutCartsNestedInput;
};

export type CartProductUncheckedUpdateWithoutCartInput = {
	productId?: Prisma.StringFieldUpdateOperationsInput | string;
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type CartProductUncheckedUpdateManyWithoutCartInput = {
	productId?: Prisma.StringFieldUpdateOperationsInput | string;
	quantity?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type CartProductSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetSelect<
	{
		cartId?: boolean;
		productId?: boolean;
		quantity?: boolean;
		cart?: boolean | Prisma.CartDefaultArgs<ExtArgs>;
		product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>;
	},
	ExtArgs['result']['cartProduct']
>;

export type CartProductSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetSelect<
	{
		cartId?: boolean;
		productId?: boolean;
		quantity?: boolean;
		cart?: boolean | Prisma.CartDefaultArgs<ExtArgs>;
		product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>;
	},
	ExtArgs['result']['cartProduct']
>;

export type CartProductSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetSelect<
	{
		cartId?: boolean;
		productId?: boolean;
		quantity?: boolean;
		cart?: boolean | Prisma.CartDefaultArgs<ExtArgs>;
		product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>;
	},
	ExtArgs['result']['cartProduct']
>;

export type CartProductSelectScalar = {
	cartId?: boolean;
	productId?: boolean;
	quantity?: boolean;
};

export type CartProductOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = runtime.Types.Extensions.GetOmit<
	'cartId' | 'productId' | 'quantity',
	ExtArgs['result']['cartProduct']
>;
export type CartProductInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	cart?: boolean | Prisma.CartDefaultArgs<ExtArgs>;
	product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>;
};
export type CartProductIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	cart?: boolean | Prisma.CartDefaultArgs<ExtArgs>;
	product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>;
};
export type CartProductIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	cart?: boolean | Prisma.CartDefaultArgs<ExtArgs>;
	product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>;
};

export type $CartProductPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	name: 'CartProduct';
	objects: {
		cart: Prisma.$CartPayload<ExtArgs>;
		product: Prisma.$ProductPayload<ExtArgs>;
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			cartId: string;
			productId: string;
			quantity: number;
		},
		ExtArgs['result']['cartProduct']
	>;
	composites: {};
};

export type CartProductGetPayload<
	S extends boolean | null | undefined | CartProductDefaultArgs
> = runtime.Types.Result.GetResult<Prisma.$CartProductPayload, S>;

export type CartProductCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = Omit<
	CartProductFindManyArgs,
	'select' | 'include' | 'distinct' | 'omit'
> & {
	select?: CartProductCountAggregateInputType | true;
};

export interface CartProductDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {}
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>['model']['CartProduct'];
		meta: { name: 'CartProduct' };
	};
	/**
	 * Find zero or one CartProduct that matches the filter.
	 * @param {CartProductFindUniqueArgs} args - Arguments to find a CartProduct
	 * @example
	 * // Get one CartProduct
	 * const cartProduct = await prisma.cartProduct.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends CartProductFindUniqueArgs>(
		args: Prisma.SelectSubset<T, CartProductFindUniqueArgs<ExtArgs>>
	): Prisma.Prisma__CartProductClient<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'findUnique',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one CartProduct that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {CartProductFindUniqueOrThrowArgs} args - Arguments to find a CartProduct
	 * @example
	 * // Get one CartProduct
	 * const cartProduct = await prisma.cartProduct.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends CartProductFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, CartProductFindUniqueOrThrowArgs<ExtArgs>>
	): Prisma.Prisma__CartProductClient<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'findUniqueOrThrow',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first CartProduct that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CartProductFindFirstArgs} args - Arguments to find a CartProduct
	 * @example
	 * // Get one CartProduct
	 * const cartProduct = await prisma.cartProduct.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends CartProductFindFirstArgs>(
		args?: Prisma.SelectSubset<T, CartProductFindFirstArgs<ExtArgs>>
	): Prisma.Prisma__CartProductClient<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'findFirst',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first CartProduct that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CartProductFindFirstOrThrowArgs} args - Arguments to find a CartProduct
	 * @example
	 * // Get one CartProduct
	 * const cartProduct = await prisma.cartProduct.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends CartProductFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, CartProductFindFirstOrThrowArgs<ExtArgs>>
	): Prisma.Prisma__CartProductClient<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'findFirstOrThrow',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more CartProducts that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CartProductFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all CartProducts
	 * const cartProducts = await prisma.cartProduct.findMany()
	 *
	 * // Get first 10 CartProducts
	 * const cartProducts = await prisma.cartProduct.findMany({ take: 10 })
	 *
	 * // Only select the `cartId`
	 * const cartProductWithCartIdOnly = await prisma.cartProduct.findMany({ select: { cartId: true } })
	 *
	 */
	findMany<T extends CartProductFindManyArgs>(
		args?: Prisma.SelectSubset<T, CartProductFindManyArgs<ExtArgs>>
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'findMany',
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a CartProduct.
	 * @param {CartProductCreateArgs} args - Arguments to create a CartProduct.
	 * @example
	 * // Create one CartProduct
	 * const CartProduct = await prisma.cartProduct.create({
	 *   data: {
	 *     // ... data to create a CartProduct
	 *   }
	 * })
	 *
	 */
	create<T extends CartProductCreateArgs>(
		args: Prisma.SelectSubset<T, CartProductCreateArgs<ExtArgs>>
	): Prisma.Prisma__CartProductClient<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'create',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many CartProducts.
	 * @param {CartProductCreateManyArgs} args - Arguments to create many CartProducts.
	 * @example
	 * // Create many CartProducts
	 * const cartProduct = await prisma.cartProduct.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends CartProductCreateManyArgs>(
		args?: Prisma.SelectSubset<T, CartProductCreateManyArgs<ExtArgs>>
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many CartProducts and returns the data saved in the database.
	 * @param {CartProductCreateManyAndReturnArgs} args - Arguments to create many CartProducts.
	 * @example
	 * // Create many CartProducts
	 * const cartProduct = await prisma.cartProduct.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many CartProducts and only return the `cartId`
	 * const cartProductWithCartIdOnly = await prisma.cartProduct.createManyAndReturn({
	 *   select: { cartId: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends CartProductCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, CartProductCreateManyAndReturnArgs<ExtArgs>>
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'createManyAndReturn',
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a CartProduct.
	 * @param {CartProductDeleteArgs} args - Arguments to delete one CartProduct.
	 * @example
	 * // Delete one CartProduct
	 * const CartProduct = await prisma.cartProduct.delete({
	 *   where: {
	 *     // ... filter to delete one CartProduct
	 *   }
	 * })
	 *
	 */
	delete<T extends CartProductDeleteArgs>(
		args: Prisma.SelectSubset<T, CartProductDeleteArgs<ExtArgs>>
	): Prisma.Prisma__CartProductClient<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'delete',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one CartProduct.
	 * @param {CartProductUpdateArgs} args - Arguments to update one CartProduct.
	 * @example
	 * // Update one CartProduct
	 * const cartProduct = await prisma.cartProduct.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends CartProductUpdateArgs>(
		args: Prisma.SelectSubset<T, CartProductUpdateArgs<ExtArgs>>
	): Prisma.Prisma__CartProductClient<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'update',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more CartProducts.
	 * @param {CartProductDeleteManyArgs} args - Arguments to filter CartProducts to delete.
	 * @example
	 * // Delete a few CartProducts
	 * const { count } = await prisma.cartProduct.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends CartProductDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, CartProductDeleteManyArgs<ExtArgs>>
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more CartProducts.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CartProductUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many CartProducts
	 * const cartProduct = await prisma.cartProduct.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends CartProductUpdateManyArgs>(
		args: Prisma.SelectSubset<T, CartProductUpdateManyArgs<ExtArgs>>
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more CartProducts and returns the data updated in the database.
	 * @param {CartProductUpdateManyAndReturnArgs} args - Arguments to update many CartProducts.
	 * @example
	 * // Update many CartProducts
	 * const cartProduct = await prisma.cartProduct.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more CartProducts and only return the `cartId`
	 * const cartProductWithCartIdOnly = await prisma.cartProduct.updateManyAndReturn({
	 *   select: { cartId: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends CartProductUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, CartProductUpdateManyAndReturnArgs<ExtArgs>>
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'updateManyAndReturn',
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one CartProduct.
	 * @param {CartProductUpsertArgs} args - Arguments to update or create a CartProduct.
	 * @example
	 * // Update or create a CartProduct
	 * const cartProduct = await prisma.cartProduct.upsert({
	 *   create: {
	 *     // ... data to create a CartProduct
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the CartProduct we want to update
	 *   }
	 * })
	 */
	upsert<T extends CartProductUpsertArgs>(
		args: Prisma.SelectSubset<T, CartProductUpsertArgs<ExtArgs>>
	): Prisma.Prisma__CartProductClient<
		runtime.Types.Result.GetResult<
			Prisma.$CartProductPayload<ExtArgs>,
			T,
			'upsert',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of CartProducts.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CartProductCountArgs} args - Arguments to filter CartProducts to count.
	 * @example
	 * // Count the number of CartProducts
	 * const count = await prisma.cartProduct.count({
	 *   where: {
	 *     // ... the filter for the CartProducts we want to count
	 *   }
	 * })
	 **/
	count<T extends CartProductCountArgs>(
		args?: Prisma.Subset<T, CartProductCountArgs>
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<'select', any>
			? T['select'] extends true
				? number
				: Prisma.GetScalarType<T['select'], CartProductCountAggregateOutputType>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a CartProduct.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CartProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends CartProductAggregateArgs>(
		args: Prisma.Subset<T, CartProductAggregateArgs>
	): Prisma.PrismaPromise<GetCartProductAggregateType<T>>;

	/**
	 * Group by CartProduct.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CartProductGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends CartProductGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<'skip', Prisma.Keys<T>>,
			Prisma.Extends<'take', Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: CartProductGroupByArgs['orderBy'] }
			: { orderBy?: CartProductGroupByArgs['orderBy'] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T['having']>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										'Field ',
										P,
										` in "having" needs to be provided in "by"`
									];
					}[HavingFields]
				: 'take' extends Prisma.Keys<T>
					? 'orderBy' extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: 'skip' extends Prisma.Keys<T>
						? 'orderBy' extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
	>(
		args: Prisma.SubsetIntersection<T, CartProductGroupByArgs, OrderByArg> &
			InputErrors
	): {} extends InputErrors
		? GetCartProductGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the CartProduct model
	 */
	readonly fields: CartProductFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for CartProduct.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CartProductClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {}
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: 'PrismaPromise';
	cart<T extends Prisma.CartDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.CartDefaultArgs<ExtArgs>>
	): Prisma.Prisma__CartClient<
		| runtime.Types.Result.GetResult<
				Prisma.$CartPayload<ExtArgs>,
				T,
				'findUniqueOrThrow',
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	product<T extends Prisma.ProductDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.ProductDefaultArgs<ExtArgs>>
	): Prisma.Prisma__ProductClient<
		| runtime.Types.Result.GetResult<
				Prisma.$ProductPayload<ExtArgs>,
				T,
				'findUniqueOrThrow',
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the CartProduct model
 */
export interface CartProductFieldRefs {
	readonly cartId: Prisma.FieldRef<'CartProduct', 'String'>;
	readonly productId: Prisma.FieldRef<'CartProduct', 'String'>;
	readonly quantity: Prisma.FieldRef<'CartProduct', 'Int'>;
}

// Custom InputTypes
/**
 * CartProduct findUnique
 */
export type CartProductFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
	/**
	 * Filter, which CartProduct to fetch.
	 */
	where: Prisma.CartProductWhereUniqueInput;
};

/**
 * CartProduct findUniqueOrThrow
 */
export type CartProductFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
	/**
	 * Filter, which CartProduct to fetch.
	 */
	where: Prisma.CartProductWhereUniqueInput;
};

/**
 * CartProduct findFirst
 */
export type CartProductFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
	/**
	 * Filter, which CartProduct to fetch.
	 */
	where?: Prisma.CartProductWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of CartProducts to fetch.
	 */
	orderBy?:
		| Prisma.CartProductOrderByWithRelationInput
		| Prisma.CartProductOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for CartProducts.
	 */
	cursor?: Prisma.CartProductWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` CartProducts from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` CartProducts.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of CartProducts.
	 */
	distinct?:
		| Prisma.CartProductScalarFieldEnum
		| Prisma.CartProductScalarFieldEnum[];
};

/**
 * CartProduct findFirstOrThrow
 */
export type CartProductFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
	/**
	 * Filter, which CartProduct to fetch.
	 */
	where?: Prisma.CartProductWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of CartProducts to fetch.
	 */
	orderBy?:
		| Prisma.CartProductOrderByWithRelationInput
		| Prisma.CartProductOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for CartProducts.
	 */
	cursor?: Prisma.CartProductWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` CartProducts from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` CartProducts.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of CartProducts.
	 */
	distinct?:
		| Prisma.CartProductScalarFieldEnum
		| Prisma.CartProductScalarFieldEnum[];
};

/**
 * CartProduct findMany
 */
export type CartProductFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
	/**
	 * Filter, which CartProducts to fetch.
	 */
	where?: Prisma.CartProductWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of CartProducts to fetch.
	 */
	orderBy?:
		| Prisma.CartProductOrderByWithRelationInput
		| Prisma.CartProductOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing CartProducts.
	 */
	cursor?: Prisma.CartProductWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` CartProducts from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` CartProducts.
	 */
	skip?: number;
	distinct?:
		| Prisma.CartProductScalarFieldEnum
		| Prisma.CartProductScalarFieldEnum[];
};

/**
 * CartProduct create
 */
export type CartProductCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
	/**
	 * The data needed to create a CartProduct.
	 */
	data: Prisma.XOR<
		Prisma.CartProductCreateInput,
		Prisma.CartProductUncheckedCreateInput
	>;
};

/**
 * CartProduct createMany
 */
export type CartProductCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * The data used to create many CartProducts.
	 */
	data: Prisma.CartProductCreateManyInput | Prisma.CartProductCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * CartProduct createManyAndReturn
 */
export type CartProductCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * The data used to create many CartProducts.
	 */
	data: Prisma.CartProductCreateManyInput | Prisma.CartProductCreateManyInput[];
	skipDuplicates?: boolean;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * CartProduct update
 */
export type CartProductUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
	/**
	 * The data needed to update a CartProduct.
	 */
	data: Prisma.XOR<
		Prisma.CartProductUpdateInput,
		Prisma.CartProductUncheckedUpdateInput
	>;
	/**
	 * Choose, which CartProduct to update.
	 */
	where: Prisma.CartProductWhereUniqueInput;
};

/**
 * CartProduct updateMany
 */
export type CartProductUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * The data used to update CartProducts.
	 */
	data: Prisma.XOR<
		Prisma.CartProductUpdateManyMutationInput,
		Prisma.CartProductUncheckedUpdateManyInput
	>;
	/**
	 * Filter which CartProducts to update
	 */
	where?: Prisma.CartProductWhereInput;
	/**
	 * Limit how many CartProducts to update.
	 */
	limit?: number;
};

/**
 * CartProduct updateManyAndReturn
 */
export type CartProductUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * The data used to update CartProducts.
	 */
	data: Prisma.XOR<
		Prisma.CartProductUpdateManyMutationInput,
		Prisma.CartProductUncheckedUpdateManyInput
	>;
	/**
	 * Filter which CartProducts to update
	 */
	where?: Prisma.CartProductWhereInput;
	/**
	 * Limit how many CartProducts to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * CartProduct upsert
 */
export type CartProductUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
	/**
	 * The filter to search for the CartProduct to update in case it exists.
	 */
	where: Prisma.CartProductWhereUniqueInput;
	/**
	 * In case the CartProduct found by the `where` argument doesn't exist, create a new CartProduct with this data.
	 */
	create: Prisma.XOR<
		Prisma.CartProductCreateInput,
		Prisma.CartProductUncheckedCreateInput
	>;
	/**
	 * In case the CartProduct was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.CartProductUpdateInput,
		Prisma.CartProductUncheckedUpdateInput
	>;
};

/**
 * CartProduct delete
 */
export type CartProductDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
	/**
	 * Filter which CartProduct to delete.
	 */
	where: Prisma.CartProductWhereUniqueInput;
};

/**
 * CartProduct deleteMany
 */
export type CartProductDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Filter which CartProducts to delete
	 */
	where?: Prisma.CartProductWhereInput;
	/**
	 * Limit how many CartProducts to delete.
	 */
	limit?: number;
};

/**
 * CartProduct without action
 */
export type CartProductDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> = {
	/**
	 * Select specific fields to fetch from the CartProduct
	 */
	select?: Prisma.CartProductSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CartProduct
	 */
	omit?: Prisma.CartProductOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CartProductInclude<ExtArgs> | null;
};
